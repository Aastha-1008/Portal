{"ast":null,"code":"/*\nBased on the work of Tom Wu\nhttp://www-cs-students.stanford.edu/~tjw/jsbn/\nhttp://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE\n*/\n\nimport { BigInteger } from 'jsbn';\nimport SHA256 from 'crypto-js/sha256';\nconst digestInfoHead = {\n  sha256: '3031300d060960864801650304020105000420'\n};\nconst digestAlgs = {\n  sha256: SHA256\n};\nfunction RSAVerifier(modulus, exp) {\n  this.n = null;\n  this.e = 0;\n  if (modulus && modulus.length > 0 && exp && exp.length > 0) {\n    this.n = new BigInteger(modulus, 16);\n    this.e = parseInt(exp, 16);\n  } else {\n    throw new Error('Invalid key data');\n  }\n}\nfunction getAlgorithmFromDigest(hDigestInfo) {\n  for (let algName in digestInfoHead) {\n    const head = digestInfoHead[algName];\n    const len = head.length;\n    if (hDigestInfo.substring(0, len) === head) {\n      return {\n        alg: algName,\n        hash: hDigestInfo.substring(len)\n      };\n    }\n  }\n  return [];\n}\nRSAVerifier.prototype.verify = function (msg, encodedSignature) {\n  const decodedSignature = encodedSignature.replace(/[^0-9a-f]|[\\s\\n]]/gi, '');\n  const signature = new BigInteger(decodedSignature, 16);\n  if (signature.bitLength() > this.n.bitLength()) {\n    //Signature does not match with the key modulus.\n    return false;\n  }\n  const decryptedSignature = signature.modPowInt(this.e, this.n);\n  const digest = decryptedSignature.toString(16).replace(/^1f+00/, '');\n  const digestInfo = getAlgorithmFromDigest(digest);\n  if (digestInfo.length === 0) {\n    //Hashing algorithm is not found\n    return false;\n  }\n  if (!digestAlgs.hasOwnProperty(digestInfo.alg)) {\n    //Hashing algorithm is not supported\n    return false;\n  }\n  const msgHash = digestAlgs[digestInfo.alg](msg).toString();\n  return digestInfo.hash === msgHash;\n};\nexport default RSAVerifier;","map":null,"metadata":{},"sourceType":"module"}