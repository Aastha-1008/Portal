{"ast":null,"code":"import AuthError from '../auth/authError';\nimport RSAVerifier from './rsa-verifier';\nimport * as base64 from './base64';\nconst jwtDecoder = require('jwt-decode');\nconst ALLOWED_ALGORITHMS = ['RS256', 'HS256'];\n\n/**\n * Verifies that an ID token is signed with a supported algorithm (HS256 or RS256), and verifies the signature\n * if signed with RS256. Note that this function is specific to the internals of this SDK, and not supported for general use.\n * @param {String} idToken the ID token\n * @param {Object} options required to verify an ID token's signature\n * @param {String} [options.domain] the Auth0 domain of the token's issuer\n * @returns {Promise} A promise that resolves to the decoded payload of the ID token, or rejects if the verification fails.\n */\nexport const verifySignature = (idToken, options) => {\n  let header, payload;\n  try {\n    header = jwtDecoder(idToken, {\n      header: true\n    });\n    payload = jwtDecoder(idToken);\n  } catch (err) {\n    return Promise.reject(idTokenError({\n      error: 'token_decoding_error',\n      desc: 'ID token could not be decoded'\n    }));\n  }\n  const alg = header.alg;\n  if (!ALLOWED_ALGORITHMS.includes(alg)) {\n    return Promise.reject(idTokenError({\n      error: 'invalid_algorithm',\n      desc: `Signature algorithm of \"${alg}\" is not supported. Expected \"RS256\" or \"HS256\".`\n    }));\n  }\n\n  // HS256 tokens require private key, which cannot be stored securely in public clients.\n  // Since the ID token exchange is done via CODE with PKCE flow, we can skip signature verification in this case.\n  if (alg === 'HS256') {\n    return Promise.resolve(payload);\n  }\n  return getJwk(options.domain, header.kid).then(jwk => {\n    const rsaVerifier = rsaVerifierForKey(jwk);\n    const encodedParts = idToken.split('.');\n    const headerAndPayload = encodedParts[0] + '.' + encodedParts[1];\n    const signature = base64.decodeToHEX(encodedParts[2]);\n    if (rsaVerifier.verify(headerAndPayload, signature)) {\n      return Promise.resolve(payload);\n    }\n    return Promise.reject(idTokenError({\n      error: 'invalid_signature',\n      desc: 'Invalid ID token signature'\n    }));\n  });\n};\nconst rsaVerifierForKey = jwk => {\n  const modulus = base64.decodeToHEX(jwk.n);\n  const exponent = base64.decodeToHEX(jwk.e);\n  return new RSAVerifier(modulus, exponent);\n};\nconst getJwk = (domain, kid) => {\n  return getJwksUri(domain).then(uri => fetchJson(uri)).then(jwk => {\n    const keys = jwk.keys;\n    const key = keys.filter(k => k.use === 'sig' && k.kty === 'RSA' && k.kid && k.n && k.e).find(k => k.kid === kid);\n    if (!key) {\n      throw new Error('Key not present');\n    }\n    return Promise.resolve(key);\n  }).catch(err => {\n    return Promise.reject(idTokenError({\n      error: 'key_retrieval_error',\n      desc: `Could not find a public key for Key ID (kid) \"${kid}\"`\n    }));\n  });\n};\nconst getJwksUri = domain => {\n  return fetch(`https://${domain}/.well-known/openid-configuration`).then(resp => resp.json()).then(openIdConfig => openIdConfig.jwks_uri);\n};\nconst fetchJson = uri => {\n  return fetch(uri).then(resp => resp.json());\n};\nconst idTokenError = err => {\n  return new AuthError({\n    json: {\n      error: `a0.idtoken.${err.error}`,\n      error_description: err.desc\n    },\n    status: 0\n  });\n};","map":null,"metadata":{},"sourceType":"module"}