{"ast":null,"code":"import AuthError from '../auth/authError';\nimport { verifySignature } from './signatureVerifier';\n\n// default clock skew, in seconds\nconst DEFAULT_LEEWAY = 60;\n\n/**\n * Verifies an ID token according to the OIDC specification. Note that this function is specific to the internals of this SDK,\n * and is not supported for general use.\n * @param {String} idToken the string token to verify\n * @param {Object}options the options required to run this verification\n * @returns {Promise} A promise that resolves if the verification is successful, or will reject the promise if validation fails\n */\nexport const verifyToken = (idToken, options) => {\n  if (typeof idToken !== 'string') {\n    return Promise.resolve();\n  }\n  return verifySignature(idToken, {\n    domain: options.domain\n  }).then(payload => validateClaims(payload, options)).then(() => Promise.resolve());\n};\nconst validateClaims = (payload, opts) => {\n  // Issuer\n  if (typeof payload.iss !== 'string') {\n    return Promise.reject(idTokenError({\n      error: 'missing_issuer_claim',\n      desc: 'Issuer (iss) claim must be a string present in the ID token'\n    }));\n  }\n  if (payload.iss !== 'https://' + opts.domain + '/') {\n    return Promise.reject(idTokenError({\n      error: 'invalid_issuer_claim',\n      desc: `Issuer (iss) claim mismatch in the ID token; expected \"https://${opts.domain}/\", found \"${payload.iss}\"`\n    }));\n  }\n\n  // Subject\n  if (typeof payload.sub !== 'string') {\n    return Promise.reject(idTokenError({\n      error: 'missing_subject_claim',\n      desc: 'Subject (sub) claim must be a string present in the ID token'\n    }));\n  }\n\n  // Audience\n  if (!(typeof payload.aud === 'string' || Array.isArray(payload.aud))) {\n    return Promise.reject(idTokenError({\n      error: 'missing_audience_claim',\n      desc: 'Audience (aud) claim must be a string or array of strings present in the ID token'\n    }));\n  }\n  if (Array.isArray(payload.aud) && !payload.aud.includes(opts.clientId)) {\n    return Promise.reject(idTokenError({\n      error: 'invalid_audience_claim',\n      desc: `Audience (aud) claim mismatch in the ID token; expected \"${opts.clientId}\" but was not one of \"${payload.aud.join(', ')}\"`\n    }));\n  } else if (typeof payload.aud === 'string' && payload.aud !== opts.clientId) {\n    return Promise.reject(idTokenError({\n      error: 'invalid_audience_claim',\n      desc: `Audience (aud) claim mismatch in the ID token; expected \"${opts.clientId}\" but found \"${payload.aud}\"`\n    }));\n  }\n\n  //--Time validation (epoch)--\n  const now = opts._clock ? getEpochTimeInSeconds(opts._clock) : getEpochTimeInSeconds(new Date());\n  const leeway = typeof opts.leeway === 'number' ? opts.leeway : DEFAULT_LEEWAY;\n\n  //Expires at\n  if (typeof payload.exp !== 'number') {\n    return Promise.reject(idTokenError({\n      error: 'missing_expires_at_claim',\n      desc: 'Expiration Time (exp) claim must be a number present in the ID token'\n    }));\n  }\n  const expTime = payload.exp + leeway;\n  if (now > expTime) {\n    return Promise.reject(idTokenError({\n      error: 'invalid_expires_at_claim',\n      desc: `Expiration Time (exp) claim error in the ID token; current time \"${now}\" is after expiration time \"${expTime}\"`\n    }));\n  }\n\n  //Issued at\n  if (typeof payload.iat !== 'number') {\n    return Promise.reject(idTokenError({\n      error: 'missing_issued_at_claim',\n      desc: 'Issued At (iat) claim must be a number present in the ID token'\n    }));\n  }\n\n  //Nonce\n  if (opts.nonce) {\n    if (typeof payload.nonce !== 'string') {\n      return Promise.reject(idTokenError({\n        error: 'missing_nonce_claim',\n        desc: 'Nonce (nonce) claim must be a string present in the ID token'\n      }));\n    }\n    if (payload.nonce !== opts.nonce) {\n      return Promise.reject(idTokenError({\n        error: 'invalid_nonce_claim',\n        desc: `Nonce (nonce) claim mismatch in the ID token; expected \"${opts.nonce}\", found \"${payload.nonce}\"`\n      }));\n    }\n  }\n\n  // Organization ID\n  if (opts.orgId) {\n    if (typeof payload.org_id !== 'string') {\n      return Promise.reject(idTokenError({\n        error: 'missing_org_id_claim',\n        desc: 'Organization ID (org_id) claim must be a string present in the ID token'\n      }));\n    }\n    if (payload.org_id !== opts.orgId) {\n      return Promise.reject(idTokenError({\n        error: 'invalid_org_id_claim',\n        desc: `Organization ID (org_id) claim mismatch in the ID token; expected \"${opts.orgId}\", found \"${payload.org_id}\"`\n      }));\n    }\n  }\n\n  //Authorized party\n  if (Array.isArray(payload.aud) && payload.aud.length > 1) {\n    if (typeof payload.azp !== 'string') {\n      return Promise.reject(idTokenError({\n        error: 'missing_authorized_party_claim',\n        desc: 'Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values'\n      }));\n    }\n    if (payload.azp !== opts.clientId) {\n      return Promise.reject(idTokenError({\n        error: 'invalid_authorized_party_claim',\n        desc: `Authorized Party (azp) claim mismatch in the ID token; expected \"${opts.clientId}\", found \"${payload.azp}\"`\n      }));\n    }\n  }\n\n  //Authentication time\n  if (typeof opts.maxAge === 'number') {\n    if (typeof payload.auth_time !== 'number') {\n      return Promise.reject(idTokenError({\n        error: 'missing_authorization_time_claim',\n        desc: 'Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified'\n      }));\n    }\n    const authValidUntil = payload.auth_time + opts.maxAge + leeway;\n    if (now > authValidUntil) {\n      return Promise.reject(idTokenError({\n        error: 'invalid_authorization_time_claim',\n        desc: `Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time \"${now}\" is after last auth time \"${authValidUntil}\"`\n      }));\n    }\n  }\n  return Promise.resolve();\n};\nconst getEpochTimeInSeconds = date => {\n  return Math.round(date.getTime() / 1000);\n};\nconst idTokenError = function () {\n  let {\n    error = 'verification_error',\n    desc = 'Error verifying ID token'\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return new AuthError({\n    json: {\n      error: `a0.idtoken.${error}`,\n      error_description: desc\n    },\n    status: 0\n  });\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}