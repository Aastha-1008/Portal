{"ast":null,"code":"import Client from '../networking';\nimport { apply } from '../utils/whitelist';\nimport { toCamelCase } from '../utils/camel';\nimport AuthError from './authError';\nimport Auth0Error from './auth0Error';\nfunction responseHandler(response) {\n  let exceptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (response.ok && response.json) {\n    return toCamelCase(response.json, exceptions);\n  }\n  throw new AuthError(response);\n}\n\n/**\n * Auth0 Auth API\n *\n * @see https://auth0.com/docs/api/authentication\n */\nclass Auth {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.client = new Client(options);\n    const {\n      clientId\n    } = options;\n    if (!clientId) {\n      throw new Error('Missing clientId in parameters');\n    }\n    this.domain = this.client.domain;\n    this.clientId = clientId;\n  }\n\n  /**\n   * Builds the full authorize endpoint url in the Authorization Server (AS) with given parameters.\n   *\n   * @param {Object} parameters parameters to send to `/authorize`\n   * @param {String} parameters.responseType type of the response to get from `/authorize`.\n   * @param {String} parameters.redirectUri where the AS will redirect back after success or failure.\n   * @param {String} parameters.state random string to prevent CSRF attacks.\n   * @returns {String} authorize url with specified parameters to redirect to for AuthZ/AuthN.\n   * @see https://auth0.com/docs/api/authentication#authorize-client\n   */\n  authorizeUrl() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const query = apply({\n      parameters: {\n        redirectUri: {\n          required: true,\n          toName: 'redirect_uri'\n        },\n        responseType: {\n          required: true,\n          toName: 'response_type'\n        },\n        state: {\n          required: true\n        }\n      },\n      whitelist: false\n    }, parameters);\n    return this.client.url('/authorize', {\n      ...query,\n      client_id: this.clientId\n    }, true);\n  }\n\n  /**\n   * Builds the full logout endpoint url in the Authorization Server (AS) with given parameters.\n   *\n   * @param {Object} parameters parameters to send to `/v2/logout`\n   * @param {Boolean} [parameters.federated] if the logout should include removing session for federated IdP.\n   * @param {String} [parameters.clientId] client identifier of the one requesting the logout\n   * @param {String} [parameters.returnTo] url where the user is redirected to after logout. It must be declared in you Auth0 Dashboard\n   * @returns {String} logout url with specified parameters\n   * @see https://auth0.com/docs/api/authentication#logout\n   */\n  logoutUrl() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const query = apply({\n      parameters: {\n        federated: {\n          required: false\n        },\n        clientId: {\n          required: false,\n          toName: 'client_id'\n        },\n        returnTo: {\n          required: false\n        }\n      }\n    }, parameters);\n    return this.client.url('/v2/logout', {\n      ...query\n    }, true);\n  }\n\n  /**\n   * Exchanges a code obtained via `/authorize` (w/PKCE) for the user's tokens\n   *\n   * @param {Object} parameters parameters used to obtain tokens from a code\n   * @param {String} parameters.code code returned by `/authorize`.\n   * @param {String} parameters.redirectUri original redirectUri used when calling `/authorize`.\n   * @param {String} parameters.verifier value used to generate the code challenge sent to `/authorize`.\n   * @returns {Promise}\n   * @see https://auth0.com/docs/api-auth/grant/authorization-code-pkce\n   */\n  exchange() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const payload = apply({\n      parameters: {\n        code: {\n          required: true\n        },\n        verifier: {\n          required: true,\n          toName: 'code_verifier'\n        },\n        redirectUri: {\n          required: true,\n          toName: 'redirect_uri'\n        }\n      }\n    }, parameters);\n    return this.client.post('/oauth/token', {\n      ...payload,\n      client_id: this.clientId,\n      grant_type: 'authorization_code'\n    }).then(responseHandler);\n  }\n\n  /**\n   * Exchanges an external token obtained via a native social authentication solution for the user's tokens\n   *\n   * @param {Object} parameters parameters used to obtain user tokens from an external provider's token\n   * @param {String} parameters.subjectToken token returned by the native social authentication solution\n   * @param {String} parameters.subjectTokenType identifier that indicates the native social authentication solution\n   * @param {Object} [parameters.userProfile] additional profile attributes to set or override, only on select native social authentication solutions\n   * @param {String} [parameters.audience] API audience to request\n   * @param {String} [parameters.scope] scopes requested for the issued tokens. e.g. `openid profile`\n   * @returns {Promise}\n   *\n   * @see https://auth0.com/docs/api/authentication#token-exchange-for-native-social\n   */\n  exchangeNativeSocial() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const payload = apply({\n      parameters: {\n        subjectToken: {\n          required: true,\n          toName: 'subject_token'\n        },\n        subjectTokenType: {\n          required: true,\n          toName: 'subject_token_type'\n        },\n        userProfile: {\n          required: false,\n          toName: 'user_profile'\n        },\n        audience: {\n          required: false\n        },\n        scope: {\n          required: false\n        }\n      }\n    }, parameters);\n    return this.client.post('/oauth/token', {\n      ...payload,\n      client_id: this.clientId,\n      grant_type: 'urn:ietf:params:oauth:grant-type:token-exchange'\n    }).then(responseHandler);\n  }\n\n  /**\n   * Performs Auth with user credentials using the Password Realm Grant\n   *\n   * @param {Object} parameters password realm parameters\n   * @param {String} parameters.username user's username or email\n   * @param {String} parameters.password user's password\n   * @param {String} parameters.realm name of the Realm where to Auth (or connection name)\n   * @param {String} [parameters.audience] identifier of Resource Server (RS) to be included as audience (aud claim) of the issued access token\n   * @param {String} [parameters.scope] scopes requested for the issued tokens. e.g. `openid profile`\n   * @returns {Promise}\n   * @see https://auth0.com/docs/api-auth/grant/password#realm-support\n   */\n  passwordRealm() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const payload = apply({\n      parameters: {\n        username: {\n          required: true\n        },\n        password: {\n          required: true\n        },\n        realm: {\n          required: true\n        },\n        audience: {\n          required: false\n        },\n        scope: {\n          required: false\n        }\n      },\n      whitelist: false\n    }, parameters);\n    return this.client.post('/oauth/token', {\n      ...payload,\n      client_id: this.clientId,\n      grant_type: 'http://auth0.com/oauth/grant-type/password-realm'\n    }).then(responseHandler);\n  }\n\n  /**\n   * Obtain new tokens using the Refresh Token obtained during Auth (requesting `offline_access` scope)\n   *\n   * @param {Object} parameters refresh token parameters\n   * @param {String} parameters.refreshToken user's issued refresh token\n   * @param {String} [parameters.scope] scopes requested for the issued tokens. e.g. `openid profile`\n   * @returns {Promise}\n   * @see https://auth0.com/docs/tokens/refresh-token/current#use-a-refresh-token\n   */\n  refreshToken() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const payload = apply({\n      parameters: {\n        refreshToken: {\n          required: true,\n          toName: 'refresh_token'\n        },\n        scope: {\n          required: false\n        }\n      },\n      whitelist: false\n    }, parameters);\n    return this.client.post('/oauth/token', {\n      ...payload,\n      client_id: this.clientId,\n      grant_type: 'refresh_token'\n    }).then(responseHandler);\n  }\n\n  /**\n   * Starts the Passworldess flow with an email connection\n   *\n   * @param {Object} parameters passwordless parameters\n   * @param {String} parameters.email the email to send the link/code to\n   * @param {String} parameters.send the passwordless strategy, either 'link' or 'code'\n   * @param {String} parameters.authParams optional parameters, used when strategy is 'linkÌ'\n   * @returns {Promise}\n   */\n  passwordlessWithEmail() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const payload = apply({\n      parameters: {\n        email: {\n          required: true\n        },\n        send: {\n          required: false\n        },\n        authParams: {\n          required: false\n        }\n      },\n      whitelist: false\n    }, parameters);\n    return this.client.post('/passwordless/start', {\n      ...payload,\n      connection: 'email',\n      client_id: this.clientId\n    }).then(responseHandler);\n  }\n\n  /**\n   * Starts the Passworldess flow with an SMS connection\n   *\n   * @param {Object} parameters passwordless parameters\n   * @param {String} parameters.phoneNumber the phone number to send the link/code to\n   * @returns {Promise}\n   */\n  passwordlessWithSMS() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const payload = apply({\n      parameters: {\n        phoneNumber: {\n          required: true,\n          toName: 'phone_number'\n        },\n        send: {\n          required: false\n        },\n        authParams: {\n          required: false\n        }\n      },\n      whitelist: false\n    }, parameters);\n    return this.client.post('/passwordless/start', {\n      ...payload,\n      connection: 'sms',\n      client_id: this.clientId\n    }).then(responseHandler);\n  }\n\n  /**\n   * Finishes the Passworldess authentication with an email connection\n   *\n   * @param {Object} parameters passwordless parameters\n   * @param {String} parameters.email the email where the link/code was received\n   * @param {String} parameters.code the code numeric value (OTP)\n   * @param {String} parameters.audience optional API audience to request\n   * @param {String} parameters.scope optional scopes to request\n   * @returns {Promise}\n   */\n  loginWithEmail() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const payload = apply({\n      parameters: {\n        email: {\n          required: true,\n          toName: 'username'\n        },\n        code: {\n          required: true,\n          toName: 'otp'\n        },\n        audience: {\n          required: false\n        },\n        scope: {\n          required: false\n        }\n      },\n      whitelist: false\n    }, parameters);\n    return this.client.post('/oauth/token', {\n      ...payload,\n      client_id: this.clientId,\n      realm: 'email',\n      grant_type: 'http://auth0.com/oauth/grant-type/passwordless/otp'\n    }).then(responseHandler);\n  }\n\n  /**\n   * Finishes the Passworldess authentication with an SMS connection\n   *\n   * @param {Object} parameters passwordless parameters\n   * @param {String} parameters.phoneNumber the phone number where the code was received\n   * @param {String} parameters.code the code numeric value (OTP)\n   * @param {String} parameters.audience optional API audience to request\n   * @param {String} parameters.scope optional scopes to request\n   * @returns {Promise}\n   */\n  loginWithSMS() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const payload = apply({\n      parameters: {\n        phoneNumber: {\n          required: true,\n          toName: 'username'\n        },\n        code: {\n          required: true,\n          toName: 'otp'\n        },\n        audience: {\n          required: false\n        },\n        scope: {\n          required: false\n        }\n      },\n      whitelist: false\n    }, parameters);\n    return this.client.post('/oauth/token', {\n      ...payload,\n      client_id: this.clientId,\n      realm: 'sms',\n      grant_type: 'http://auth0.com/oauth/grant-type/passwordless/otp'\n    }).then(responseHandler);\n  }\n\n  /**\n   * Log in a user using the One Time Password code after they have received the 'mfa_required' error.\n   * The MFA token tells the server the username or email, password, and realm values sent on the first request.\n   *\n   * Requires your client to have the **MFA OTP** Grant Type enabled.\n   * See [Client Grant Types](https://auth0.com/docs/clients/client-grant-types) to learn how to enable it.\n   *\n   * @param {Object} parameters login with OTP parameters\n   * @param {String} parameters.mfaToken the token received in the previous login response\n   * @param {String} parameters.otp the one time password code provided by the resource owner, typically obtained from an MFA application such as Google Authenticator or Guardian.\n   * @returns {Promise}\n   */\n  loginWithOTP() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const payload = apply({\n      parameters: {\n        mfaToken: {\n          required: true,\n          toName: 'mfa_token'\n        },\n        otp: {\n          required: true,\n          toName: 'otp'\n        }\n      },\n      whitelist: false\n    }, parameters);\n    return this.client.post('/oauth/token', {\n      ...payload,\n      client_id: this.clientId,\n      grant_type: 'http://auth0.com/oauth/grant-type/mfa-otp'\n    }).then(responseHandler);\n  }\n\n  /**\n   * Log in a user using an Out Of Band authentication code after they have received the 'mfa_required' error.\n   * The MFA token tells the server the username or email, password, and realm values sent on the first request.\n   *\n   * Requires your client to have the **MFA OOB** Grant Type enabled. See [Client Grant Types](https://auth0.com/docs/clients/client-grant-types) to learn how to enable it.\n   *\n   * @param {Object} parameters login with Recovery Code parameters\n   * @param {String} parameters.mfaToken the token received in the previous login response\n   * @param {String} parameters.oobCode the out of band code received in the challenge response.\n   * @param {String} parameters.bindingCode [Optional] the code used to bind the side channel (used to deliver the challenge) with the main channel you are using to authenticate. This is usually an OTP-like code delivered as part of the challenge message.\n   *\n   * @returns {Promise}\n   */\n\n  loginWithOOB() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const payload = apply({\n      parameters: {\n        mfaToken: {\n          required: true,\n          toName: 'mfa_token'\n        },\n        oobCode: {\n          required: true,\n          toName: 'oob_code'\n        },\n        bindingCode: {\n          required: false,\n          toName: 'binding_code'\n        }\n      },\n      whitelist: false\n    }, parameters);\n    return this.client.post('/oauth/token', {\n      ...payload,\n      client_id: this.clientId,\n      grant_type: 'http://auth0.com/oauth/grant-type/mfa-oob'\n    }).then(responseHandler);\n  }\n\n  /**\n   * Log in a user using a multi-factor authentication Recovery Code after they have received the 'mfa_required' error.\n   * The MFA token tells the server the username or email, password, and realm values sent on the first request.\n   *\n   * Requires your client to have the **MFA** Grant Type enabled. See [Client Grant Types](https://auth0.com/docs/clients/client-grant-types) to learn how to enable it.\n   *\n   * @param {Object} parameters login with Recovery Code parameters\n   * @param {String} parameters.mfaToken the token received in the previous login response\n   * @param {String} parameters.recoveryCode the recovery code provided by the end-user.\n   * @returns {Promise}\n   */\n  loginWithRecoveryCode() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const payload = apply({\n      parameters: {\n        mfaToken: {\n          required: true,\n          toName: 'mfa_token'\n        },\n        recoveryCode: {\n          required: true,\n          toName: 'recovery_code'\n        }\n      },\n      whitelist: false\n    }, parameters);\n    return this.client.post('/oauth/token', {\n      ...payload,\n      client_id: this.clientId,\n      grant_type: 'http://auth0.com/oauth/grant-type/mfa-recovery-code'\n    }).then(responseHandler);\n  }\n\n  /**\n   * Request a challenge for multi-factor authentication (MFA) based on the challenge types supported by the application and user.\n   * The challenge type is how the user will get the challenge and prove possession. Supported challenge types include: \"otp\" and \"oob\".\n   *\n   * @param {Object} parameters challenge request parameters\n   * @param {String} parameters.mfaToken the token received in the previous login response\n   * @param {String} parameters.challengeType A whitespace-separated list of the challenges types accepted by your application.\n   * Accepted challenge types are oob or otp. Excluding this parameter means that your client application\n   * accepts all supported challenge types.\n   * @param {String} parameters.authenticatorId The ID of the authenticator to challenge.\n   * @returns {Promise}\n   */\n  multifactorChallenge() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const payload = apply({\n      parameters: {\n        mfaToken: {\n          required: true,\n          toName: 'mfa_token'\n        },\n        challengeType: {\n          required: false,\n          toName: 'challenge_type'\n        },\n        authenticatorId: {\n          required: false,\n          toName: 'authenticator_id'\n        }\n      }\n    }, parameters);\n    return this.client.post('/mfa/challenge', {\n      ...payload,\n      client_id: this.clientId\n    }).then(responseHandler);\n  }\n\n  /**\n   * Revoke an issued refresh token\n   *\n   * @param {Object} parameters revoke token parameters\n   * @param {String} parameters.refreshToken user's issued refresh token\n   * @returns {Promise}\n   */\n  revoke() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const payload = apply({\n      parameters: {\n        refreshToken: {\n          required: true,\n          toName: 'token'\n        }\n      }\n    }, parameters);\n    return this.client.post('/oauth/revoke', {\n      ...payload,\n      client_id: this.clientId\n    }).then(response => {\n      if (response.ok) {\n        return {};\n      }\n      throw new AuthError(response);\n    });\n  }\n\n  /**\n   * Return user information using an access token\n   *\n   * @param {Object} parameters user info parameters\n   * @param {String} parameters.token user's access token\n   * @returns {Promise}\n   */\n  userInfo() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const payload = apply({\n      parameters: {\n        token: {\n          required: true\n        }\n      }\n    }, parameters);\n    const {\n      baseUrl,\n      telemetry\n    } = this.client;\n    const client = new Client({\n      baseUrl,\n      telemetry,\n      token: payload.token\n    });\n    const claims = ['sub', 'name', 'given_name', 'family_name', 'middle_name', 'nickname', 'preferred_username', 'profile', 'picture', 'website', 'email', 'email_verified', 'gender', 'birthdate', 'zoneinfo', 'locale', 'phone_number', 'phone_number_verified', 'address', 'updated_at'];\n    return client.get('/userinfo').then(response => responseHandler(response, {\n      attributes: claims,\n      whitelist: true\n    }));\n  }\n\n  /**\n   * Request an email with instructions to change password of a user\n   *\n   * @param {Object} parameters reset password parameters\n   * @param {String} parameters.email user's email\n   * @param {String} parameters.connection name of the connection of the user\n   * @returns {Promise}\n   */\n  resetPassword() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const payload = apply({\n      parameters: {\n        email: {\n          required: true\n        },\n        connection: {\n          required: true\n        }\n      }\n    }, parameters);\n    return this.client.post('/dbconnections/change_password', {\n      ...payload,\n      client_id: this.clientId\n    }).then(response => {\n      if (response.ok) {\n        return {};\n      }\n      throw new AuthError(response);\n    });\n  }\n\n  /**\n   *\n   *\n   * @param {Object} parameters create user parameters\n   * @param {String} parameters.email user's email\n   * @param {String} parameters.password user's password\n   * @param {String} parameters.connection name of the database connection where to create the user\n   * @param {String} [parameters.username] user's username\n   * @param {String} [parameters.give_name] The user's given name(s)\n   * @param {String} [parameters.family_name] The user's family name(s)\n   * @param {String} [parameters.name] The user's full name\n   * @param {String} [parameters.nickname] The user's nickname\n   * @param {String} [parameters.picture] A URI pointing to the user's picture\n   * @param {String} [parameters.metadata] additional user information that will be stored in `user_metadata`\n   * @returns {Promise}\n   */\n  createUser() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const payload = apply({\n      parameters: {\n        email: {\n          required: true\n        },\n        password: {\n          required: true\n        },\n        connection: {\n          required: true\n        },\n        username: {\n          required: false\n        },\n        given_name: {\n          required: false\n        },\n        family_name: {\n          required: false\n        },\n        name: {\n          required: false\n        },\n        nickname: {\n          required: false\n        },\n        picture: {\n          required: false\n        },\n        metadata: {\n          required: false,\n          toName: 'user_metadata'\n        }\n      }\n    }, parameters);\n    return this.client.post('/dbconnections/signup', {\n      ...payload,\n      client_id: this.clientId\n    }).then(response => {\n      if (response.ok && response.json) {\n        return toCamelCase(response.json);\n      }\n      throw new Auth0Error(response);\n    });\n  }\n}\nexport default Auth;","map":null,"metadata":{},"sourceType":"module"}